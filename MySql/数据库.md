## 数据库

### 1. 如何设计一个关系型数据库

底层：存储（文件系统）

程序实例：存储管理，缓存机制，SQL解析，日志管理，权限划分，容灾机制，索引管理，锁管理

### 2.  索引模块

#### 2.1 为什么要使用索引

- 快速查询数据（避免全表扫描）

#### 2.2 什么样的信息能成为索引

- 主键，唯一键以及普通键等

#### 2.3 索引的数据结构

- 生成索引，建立二叉查找树进行二分查找
- 生成索引，建立B-Tree结构进行查找
- 生成索引，建立B+-Tree结构进行查找
- 生成索引，建立Hash结构进行查找

#### 2.4 B-Tree

定义：

- 根节点至少包括两个孩子
- 树中每个节点最多含有m个孩子（m>=2）
- 除根节点和叶节点外，其他每个节点至少有ceil（m/2）个孩子
- 所有叶子节点都位于同一层
- ...

#### 2.5 B+-Tree

![image-20201014222034757](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20201014222034757.png)

- 非叶子节点的子树指针与关键字个数相同
- 非叶子节点的子树指针p[i]，指向关键字值[K[i],k[i+1])的子树
- 非叶子节点仅用来索引，数据都保存在叶子节点中
- 所有叶子节点均有一个链指针指向下一个叶子节点

#### 2.6 B+Tree更适合用来做存储索引

- B+树的磁盘读写代价更低
- B+树的查询效率更加稳定
- B+树更加有利对数据的扫描

#### 2.7 哈希索引

- 仅仅能满足“=”，“IN”，不能使用范围查询
- 无法被用来避免数据的排序操作
- 不能利用部分索引键查询
- 不能避免表扫描
- 遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高

#### 2.8 密集索引和稀疏索引的区别

![img](../Fig/ce9bedd0dc9013e14e5f450e2149704bef5.jpg)

![img](../Fig/59066cb190ec7579c34e2cd77a1f47e8b68.jpg)

- **聚簇索引：**将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据
- **非聚簇索引：**将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

#### 2.9 InnoDB

- 若一个主键被定义，该主键则作为密集索引
- 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
- 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
- 非主键索引存储相关健位和对应的主键值，包含两次查找

#### 2.10 如何定位并优化慢查询SQL

- 根据慢日志定位慢SQL

  ```mysql
  show variables like '%quer%';
  show status like '%slow_queries%';
  set global slow_query_log = on;
  set global long_query_time = 1;
  ```

- 使用Explain等工具分析sql

- 修改sql或尽量让sql走索引

#### 2.11 最左匹配原则

- 最左前缀匹配原则，mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就会停止匹配，比如

  ```mysql
  a=3 and b=4 and c>5 and d=6
  ```

  如果建立（a，b，c，d）顺序索引，d是用不到索引的，如果建立（a，b，d，c）的索引则都可以用到，a，b，d的顺序是可以任意调整。

- =和in可以乱序，比如a=1 and b=2 and c=3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

最左匹配原则的成因：mysql先对索引的第一个字段进行排序，再对第二个字段进行排序，也就是说第二个字段是无序的，所以直接使用第二个字段做判断是无法使用索引的。

#### 2.12 索引是建立得越多越好吗

- 数据量小的表不需要建立索引，建立会增加额外的索引开销
- 数据变更需要维护索引，因此更多的索引意味着更多的维护成本
- 更多的索引意味着需要更多的空间

### 3. 锁模块

#### 3.1MyISAM与InnoDB关于锁方面的区别是什么

- MyISAM默认用的是表级锁，不支持行级锁
  - 读锁是共享锁，写锁是排它锁
- InnoDB默认用的是行级锁，也支持表级锁
  - 走索引的时候用行级锁，不走索引的时候用的是表级锁
- 数据库锁的分类
  - 按锁的粒度划分：表级锁，行级锁，页级锁
  - 按锁级别划分：共享锁，排它锁
  - 按加锁方式划分：自动锁，显式锁
  - 按操作划分：DML锁，DDL锁
  - 按使用方式划分：可分为乐观锁，悲观锁

#### 3.2 数据库事务的四大特性

ACID

- 原子性（Atomic）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

#### 3.3 事务隔离级别以及各级别下的并发访问问题

![image-20201015120514768](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20201015120514768.png)

事务并发访问引起的问题以及如何避免

- 更新丢失--mysql所有事务隔离级别在数据库层面上均可避免
- 脏读--一个事务读到另一个事务未提交的数据--READ-COMMITTED事务隔离级别以上可避免
- 不可重复读--一个事务在多次的读操作的时候因为另一事务的提交操作导致了多次读的数据不一致--REPEATABLE-READ事务隔离级别以上可以避免
- 幻读--SERIALIZABLE事务隔离级别可以避免

#### 3.4 InnoDB可重复度隔离级别下如何避免幻读

#### 3.5 RC、RR级别下的InnoDB的非阻塞读如何实现

