## 数据库

### 数据库的三大范式是什么

第一范式：每个列都不可以再拆分

第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分

第三范式：在第二范式的基础上，非主键列只依赖于主键，而不能是依赖于主键的一部分

### 数据库的基本类型

- `1、整数类型`，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。
  `长度`：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。
  `例子`，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。

- `2、实数类型`，包括FLOAT、DOUBLE、DECIMAL。
  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。
  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。
  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。

- `3、字符串类型`，包括VARCHAR、CHAR、TEXT、BLOB
  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。
  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。
  VARCHAR存储的内容超出设置的长度时，内容会被截断。
  CHAR是定长的，根据定义的字符串长度分配足够的空间。
  CHAR会根据需要使用空格进行填充方便比较。
  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。
  CHAR存储的内容超出设置的长度时，内容同样会被截断。

  **使用策略：**
  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。
  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。
  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。
  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。

- `4、枚举类型（ENUM）`，把不重复的数据存储为一个预定义的集合。
  有时可以使用ENUM代替常用的字符串类型。
  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。
  ENUM在内部存储时，其实存的是整数。
  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。
  排序是按照内部存储的整数

- `5、日期和时间类型`，尽量使用timestamp，空间效率高于datetime，
  用整数保存时间戳通常不方便处理。
  如果需要存储微妙，可以使用bigint存储。
  看到这里，这道真题是不是就比较容易回答了。

## 引擎

### MySql储存引擎MyISAM与InnoDB区别

- **Innodb引擎**：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。

  适用场景

  - 数据增删改查都相当频繁
  - 可靠性要求比较高，要求支持事务

- **MyIASM引擎**(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。

  适用场景：

  - 频繁执行全表count语句
  - 对数据进行增删改查的频率不高，查询非常频繁
  - 没有事务

### MyISAM索引与InnoDB索引的区别？

- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。
- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。

## 索引

### 什么是索引

索引是一种以B+树数据结构作为底层实现原理，存放着数据表中所有记录的应用指针，用于快速查询和更新数据库表中数据的特殊文件。索引相当于一本书上面的目录。

### 索引的优缺点

优点：

- 大大的加快数据的检索速度

缺点：

- 索引需要进行维护，具体来说，就是回降低数据库表增删改时候的效率
- 索引需要占据物理空间

### 索引的适用场景

- WHERE
- ORDER BY：如果对没有建立索引的字段进行排序，所有数据回使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），效率极低。而对已经建立索引的字段进行排序，因为本来索引就是有序的，可以直接按照索引顺序和映射关系逐条取出数据即可，而对于分页操作，只需取出索引表某个范围内的索引对应的数据。
- JOIN：对join语句匹配关系on后面涉及到的字段建立索引能提高效率

### 索引的类型

**主键索引：**数据列不允许重复，不允许为null，一个表只能由一个主键

**唯一索引：**数据列不允许重复，允许为null，一个表允许多个唯一索引

**普通索引：**基本的索引类型，没有唯一性限制，允许为null值

**全文索引：**目前搜索引擎使用的一种关键技术

### 创建索引的原则

1. 要符合最左匹配原则
2. 对需要频繁查询的字段创建索引
3. 更新频繁的字段不适合作为索引
4. 区分度太低的字段不适合作为索引（例如性别）
5. 尽量扩展索引，不要新建索引
6. 定义外键的数据列一定要建立索引
7. 对于定义为text、imge和bit数据类型的列不要建立索引

### 创建索引的三种方式

第一种：在CREATE TABLE时候创建索引

```mysql
CREATE TABLE user_index2 (
	id INT auto_increment PRIMARY KEY,
	first_name VARCHAR (16),
	last_name VARCHAR (16),
	id_card VARCHAR (18),
	information text,
	KEY name (first_name, last_name),
	FULLTEXT KEY (information),
	UNIQUE KEY (id_card)
);
```

第二种：使用ALTER TABLE命令增加索引

```mysql
ALTER TABLE table_name ADD INDEX index_name (column_list);
```

第三种：使用CREATE INDEX 命令创建：可以对表增加普通索引或唯一索引。（但是不能创建主键索引）

```mysql
CREATE INDEX index_name ON table_name (column_list);
```

删除索引

```mysql
alter table user_index drop KEY name;
alter table user_index drop KEY id_card;
alter table user_index drop KEY information;
alter table tb_name drop primary key;
```

注意如果主键自增长，需要先取消自增长后删除

### 百万级别或以上的数据如何删除

由于直接对数据的增删改都会产生对索引文件的操作，消耗额外的IO，降低了增删改的效率，因此在删除百万级别的数据的时候：

1. 首先删除索引
2. 删除无用数据
3. 重新建立索引

### Hash索引和B+树索引的优劣

- hash索引在进行等值查询更快，但是无法进行范围查询
- hash索引不支持使用索引进行排序
- hash索引不支持模糊查询以及多列索引的最左前缀匹配
- hash索引查询效率不稳定，发生hash碰撞的时候可能查询效率极低，B+树索引可以获得稳定且较好的查询速度

### 数据库为什么使用B+树而不是B树

1. b树只适合随机检索，而b+树同时支持随机检索和顺序检索
2. b+树的空间利用率更高，可减少IO次数，因为其内部节点没有关键字具体信息的指针，只作为索引使用，因此内部节点比b树小，即能容纳更多的关键字，一次读取进内存中的关键字信息也越多，相对的IO次数就减少了
3. b+树的查询效率更加稳定
4. b+树的范围查找效率更高，解决了b树元素遍历效率低下的问题
5. 增删节点时候，b+树的效率更高

## 事务

### 事务的四大特性（ACID）

- 原子性：事务是最小的执行单位，不允许被分割
- 一致性：执行事务前后，保持数据的一致性
- 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰
- 持久性：一个事务被提交后，他对数据库中的数据改变是持久的

### 什么是脏读？幻读？不可重读？

- 脏读：一个事务读取到另一个事务未提交的数据
- 不可重复读：一个事务的两次查询之中数据不一致
- 幻读：在一个事务中两次查询得到的数据数目不一致

### 什么是事务的隔离级别，MySQL的默认隔离级别是什么

为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高分别是：Read Uncommitted、Read committed、Repeatable read、Serializable，MySQL默认采用Repeatable隔离级别。

### 隔离级别和锁的关系

在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

SERIALIZABLE 是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。

### 数据库锁的分类

按照锁的粒度来分：行级锁，表级锁，页级锁

按照锁的类型来分：共享锁，排他锁