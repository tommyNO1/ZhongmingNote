##  多线程

#### JAVA实现多线程有哪几种方式

实现Runnable接口，实现里面的Run方法
继承Thread类，重写Run方法
实现Callable接口，重写Call方法
使用线程池

#### Callable和Future的了解

实现Callable接口实现多线程的方法可以有返回值，方法可以抛出异常，并且至此泛型返回值。
Future提供了三种功能，判断任务是否完成，能够中断任务，能够获取任务执行结果，Future只是一个接口，无法直接创建对象使用，因而要使用其实现类Futuretask。

#### 线程池的参数有那些，在线程池创建一个线程的过程

- **corePoolSize**（必须）：核心线程数。默认情况下，线程会一直存活

- **maximunPoolSize**（必须）：线程池所能容纳的最大线程数。当活线程数达到该数值后，后续的新任务将被阻塞。

- **keepAliveTime**（必须）：线程闲置超时时长。如果超过该时长，非核心线程将被回收。

- **unit**（必须）：指定keepAliveTime参数的时间单位。
  
- **workQueue**（必需）：任务队列。通过线程池的execute()方法提交的Runnable对象将存储在该参数中。其采用阻塞队列实现。
  
- **threadFactory**（可选）：线程工厂。用于指定为线程池创建新线程的方式。
  
- **handler**（可选）：拒绝策略。当达到最大线程数时需要执行的饱和策略。

  任务进来时，首先执行判断，判断核心线程是否处于空闲状态，如果是，核心线程就先就执行任务，如果核心线程已满，则判断任务队列是否有地方存放该任务，若果有，就将任务保存在任务队列中，等待执行，如果满了，在判断最大可容纳的线程数，如果没有超出这个数量，就开创非核心线程执行任务，如果超出了，就调用handler实现拒绝策略。

#### volitile关键字的作用，原理

volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

#### synchronized关键字的用法，优缺点

synchronized关键字可以用于修饰代码块，成员方法和静态方法，在修饰代码块的时候需要指定同步监视器。

优点：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器；

缺点：锁的释放情况少，只有程序正常执行完成、抛出异常时和线程进入Waiting状态时释放锁；不能中断一个正在试图获得锁的过程；无法知道线程是否成功获得锁；

#### Lock接口有哪些实现类，使用场景是什么

Lock接口的实现类有ReentrantLock和ReentrantReadWriteLock的两个内部类，ReentrantLock的锁具备可重入性，而ReadWriteLock维护了一对相关的锁，一个用于只读操作，一个用于写入操作。读取锁可以由多个reader线程保持，而写入锁是独立的

#### 可重入锁的用处及实现原理，读写锁，分段锁（ConcurrentHashMap中的segment）

重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。

读写锁：但是对于Lock的另一个实现类ReadWriteLock，其读锁是共享锁，其写锁是独享锁。读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。

分段锁：当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

#### 悲观锁，乐观锁，优缺点，CAS有什么缺陷，该如何解决

独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。

CAS原理：

CAS存在三大问题：CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

1. ABA问题，因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。
2. 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
3.  只能保证一个共享变量的原子操作。

#### 线程的状态都有哪些

六个状态：新建（NEW），运行（Runnable），阻塞（Block），终止（TERMINATED），等待状态（WATING），超时等待（TIME_WATING）

#### sleep和wait的区别

相同点：都会使线程进入阻塞状态

不同点：

- sleep声明在thread中的方法，wait声明在object类的方法
- sleep能在代码任意位置调用，wait只能在同步代码块中调用
- sleep不会释放同步监视器，而wait会释放同步监视器

#### notify和notifyall的区别

- notifyAll会让所有处于等待池的的线程全部进入锁池去竞争获取锁的机会
- notify只会随机选取一个处于等待池中的线程进入锁池去竞争锁的机会



