# JVM

1. ## JVM的内存结构
   
   线程私有的：程序计数器；虚拟机栈；本地方法栈
   线程共享的：方法区（元空间）；Java堆；
2. ## JVM方法栈的工作过程，方法栈和本地方法栈有什么区别。
   
   每个方法被执行的时候，都会创建一个“栈帧”用于存储局部变量表，操作栈，方法出口等信息。
   每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈（方法栈）从入栈到出栈的过程。
   虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务
3. ## JVM的栈中引用如何和堆中的对象产生关联。
   
   对象产生时，产生的首地址储存在栈中，这样两者就关联起来了
4. ## 常见的GC算法
   
   - 引用计数法
   - 可达性分析算法
   - 标记-清除算法
   - 复制算法		适用于存活率低的场合
   - 标记-整理算法	适用于存活率高的场合
5. ## 堆内存的划分
   
   jdk7之前，堆内存划分为主要三个部分分别是新生代，老年代和永久代
   jdk8之后，将永久代从堆内存移动到了本地内存，只剩下新生代和老年代
   而新生代中有包含了三个区，分别是Eden区，Survivor1区和Survivor2区
6. ## 标记清除和标记整理算法的理解以及优缺点
   
   标记清除算法：分为标记和清楚两个阶段，首先将所有活动的对象标记出来，然后把没有被标记的对象清除掉。存在两个问题，一是两个过程的效率都不高。二是清楚之后会产生大量不连续的内存
   标记整理算法：标记阶段与标记清除算法一样，在整理阶段将所有存活的对象压缩到内存的一端，然后将边界之外的空间清除，。适用于存货对象较多的场合。
7. ## eden survivor区的比例，为什么是这个比例，eden survivor的工作过程
   
   新生成的对象首先放在年轻代的Eden区，当Eden空间满了，会触发MinorGC，存活下来的对象移动到Survivor1区，当Survivor1区满后触发MinorGC，Survivor1区的存活对象移动到Survivor2区，这样保证总有一个Survivor区为空，经过多次MinorGC仍然存货的对象移动到老年代。
8. ## JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型
   
   可达性分析，如果一个对象没有到达根对象的路径，或者说根对象开始无法引用到该对象，该对象就是不可达。可以是作为root的对象：虚拟机栈中引用的对象；方法区中静态属性引用的对象；本地方法栈引用的对象。
9. ## 强软弱虚引用的区别以及GC对他们执行怎样的操作
   
   强引用对象不会被回收，软引用对象在jvm要内存溢出的时候，会被回收，弱引用在下次GC时一定会被回收，虚引用唯一作用是在该对象回收时收到一个系统通知。
10. ## CMS垃圾回收过程，CMS的各个阶段哪两个是Stop the world的？（使用标记清理算法）
    
      初始标记：Stop the World
      并发标记：并发追溯标记、程序不会停顿
      并发预清理：虚拟机查找在执行并发标记阶段新进入老年代的对象。
      重新标记：STW，扫描CMS堆中剩余的对象
      并发清理：清理垃圾对象，并发执行
      并发重置：重置CMS手机其的数据结构
11. ## G1垃圾收集器回收过程
12. ## Java类加载过程
    
      主要分为三个阶段：加载，连接和初始化
      加载：通过ClassLoader加载class文件字节码，生成class对象
      连接：A检查：检查加载class的正确性和安全性；B准备，为类的静态变量分配存储空间并设置的初值；C解析，JVM将常量池类的符号引用替换为直接引用
      初始化：执行静态变量的赋值和静态代码块
13. ## 双亲委派模型的过程以及优势
    
      自底向上的检查类是否已经加载，自顶向下的尝试加载类，可以避免多分同样的字节码的加载





