## java基础

### HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化？

在jdk7当中，在实例化之后，底层创建了一个长度为16的一维数组Entry[] table。调用put方法，首先检查大小，看是否需要扩容，然后调用key所在类的hashCode()计算key的哈希值，此哈希值经过某种算法以后，得到在Entry数组中的存放位置。如果此位置数据为空，此时键值对添加成功。如果此位置上的数据不为空，则去比较key1与存在的数据的哈希值，若哈希值不同，这可以以链表的形式添加到数组该位置中，如果哈希值相同则调用key的equals()方法，如果equals()返回false则同上添加，否则将相同的位置的value替换。
Jdk8中，是在首次调用put方法底层才创建长度为16的数组，且底层结构变为了数组+链表+红黑树

### HashMap扩容是怎样扩容的，为什么都是2的N次幂的大小？

当HashMap的容量超过当前最大容量乘以扩容因子（默认是0.75）的时候进行扩容，由HashMap的设计者是通过位运算（length-1&hash）来求得存放的数组索引，而2的N次幂减1的而二进制形式恰为全1，一方面提升了数组的空间利用率，另一方面也提升了查询的效率

### HashMap，HashTable，ConcurrentHashMap的区别？

HashMap:线程不安全，效率高，可存储为null的key和value
HashTable：线程安全，效率低，不可存储为null的key和value
ConcurrentHashMap：线程安全，允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表不同部分进行的修改。

### 极高并发下HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的？

ConcurrentHashMap的性能更好，因为它采用了锁分离技术，允许多个操作并发进行，而HashTable只允许当前一个线程对其进行操作。

### HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么？

多线程同时操作同一个哈希表，在扩容重排的时候，可能会出现环形链表，在下一次get操作的时候无限循环
多线程put的时候，会出现被覆盖等问题

### java中四种修饰符的限制范围？

public：可以被所有其他类所访问
private：只能被自己访问和修改
protected：自身，子类以及同一包中的类可以访问
default：同一包中的类可以访问

### Object类中的方法

hashCode方法、getClass方法、toString方法、equals方法、clone方法、finalize方法

### 接口和抽象类的区别，注意JDK8的接口可以有实现。

- 一个类可以实现多个接口，但是只能实现一个抽象类。接口本身可以通过extend关键字扩展多个接口。
- 抽象类中不一定都是抽象方法，也可以是具体方法。JDK8之后接口可以由默认方法和静态方法。
- 接口中只能由static final变量，而抽象类可以有普通变量
- 抽象类主要来抽象类别，接口主要用来抽象功能

### 动态代理的两种方式，以及区别

JDk动态代理和cglib动态代理，JDK动态代理智能实现了接口的类生成代理对象，而cglib可以对任意目标对象生成代理对象，其原理是对目标对象进行继承代理。

### Java序列化的方式

实现Serializable接口（隐式序列化），实现Externalizable接口（显式序列化），实现Serializable接口以及添加writeObject和readObject方法

### 传值和传引用的区别，JAVA是怎样的，有没有传值引用

传值：把实参赋给形参，对形参的修改不会影响到实参。

传引用：以地址的方式传递参数，传递以后，形参和实参都指向同一个对象，对形参的修改将影响实参的值

### Java中的传参机制是值传递，但是对应引用类型的参数，值的内容是对象的引用

一个ArrayList在循环过程中删除，会不会出问题

for循环正向删除会遗漏连续重复的元素，而方向遍历删除则没有问题。

### @transaction注解在什么情况下会失效，为什么

方法不是public的；异常类型是否unchecked异常；数据库引擎是否至此事务；是否开启了对注解的解析；

### 面向对象的三大基本特征

封装、继承、多态

封装：**隐藏对象的属性和实现细节**，仅对外公开接口

继承：**子类继承父类的特征和行为**，它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

多态：多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。

### 五大基本原则

1. 单一职责原则：一个类专心做好一件事，不能够包罗万象
2. 开放封闭原则：对扩展开放，对修改封闭
3. 替换原则：子类必须能够替换其基类
4. 依赖倒置原则：依赖于抽象，就是高层次模型不依赖低层次模型
5. 接口隔离原则：使用多个专用的小接口，不要使用一个大的总接口

